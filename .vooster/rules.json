{
  "rules": [
    {
      "type": "prd",
      "content": "# 실시간 전철 알림 앱 PRD\n\n## 1. 제품 개요\n수도권 통근·통학자를 대상으로 지하철 열차의 실시간 지연·운행 중단 정보를 제공하고, 대체 노선 제안을 통해 출·퇴근 시간을 최소화하도록 돕는 iOS/Android 모바일 애플리케이션.\n\n## 2. 비전 & 목표\n1. 지하철 이용 시 불확실성을 제거해 사용자에게 시간∙정신적 여유를 제공한다.\n2. 돌발 상황에도 빠른 대처가 가능하도록 실시간 알림과 대체 경로를 제안한다.\n\n## 3. 핵심 지표 (Success Metrics)\n* MAU / DAU\n* 평균 알림 클릭률\n* 지연 알림 정확도 ≥ 95%\n* 앱 삭제율 < 5% (30일)\n* 일 평균 사용시간 ≥ 2분\n\n## 4. 타깃 사용자\n* 수도권(1~9호선 및 신분당선 등) 통근·통학자 (20~40대)\n* 하루 2회 이상 지하철을 이용하며, 지연·중단 시 시간손실에 민감한 직장인/학생\n\n## 5. 핵심 Pain Point\nA. 열차 지연 정보 파편화로 인한 시간 낭비\nC. 급작스러운 운행 중단 소식 부재로 통근 계획 붕괴\n\n## 6. 사용자 목표\nA. 출·퇴근 시간을 최소화해 일상 여유 확보\nB. 예상치 못한 지연·중단 상황에서도 스트레스 없이 대체 이동 결정\n\n## 7. 주요 기능 (전 기능 1차 릴리스)\n| 분류 | 기능 | 설명 |\n|------|------|------|\n| Core | 실시간 열차 도착/지연 알림 | 역/노선 기반 Push 푸시, 지연/운행중단 감지 후 즉시 전송 |\n| Core | 장애 발생•운행 중단 긴급 알림 | 사고·장애 정보를 실시간 수집하여 알림 |\n| Core | 대체 노선/경로 제안 | 지연 발생 시 우회 경로, 예상 소요 시간 제공 |\n| Personalization | 즐겨찾기 역·노선 관리 | 자주 이용 역·노선을 등록, 맞춤 알림 |\n| Personalization | 알림 시간대 설정 | 출·퇴근 시간 등 지정 시간대에만 알림 |\n| Advanced | 실시간 혼잡도/객차 혼잡 정보 | 데이터(센서/크라우드) 기반 혼잡도 표시 |\n| Advanced | 위치 기반 자동 역 식별 | GPS·BLE로 사용자의 현재 역 자동 감지 |\n| Advanced | 출·퇴근 패턴 학습 후 맞춤 푸시 | ML 기반 사용 패턴 분석, 예측 알림 |\n| Reliability | 오프라인 모드 | 지하 구간에서도 캐시 정보 표시 |\n| UX | 위젯 & 워치 컴플리케이션 | 잠금화면/스마트워치에서 간편 조회 |\n| Community | 사용자 제보 | 지연·혼잡 정보 crowdsourcing |\n\n## 8. 사용자 여정 요약\n1. 아침 7:00 – 사용자 휴대폰에 오늘의 출근 노선 정상 여부 푸시.\n2. 7:30 – 역 도착 직전, 앱이 자동으로 현재 역 인식 & 도착 시간 표시.\n3. 7:35 – 지연 5분 발생 알림 & 버스+지하철 우회 노선 제안.\n4. 18:10 – 퇴근 알림 시간대, 장애 발생 긴급 알림 전송.\n5. 18:40 – 워치에서 혼잡도 낮은 칸 확인 후 탑승.\n\n(자세한 여정은 User Journey 문서 참고)\n\n## 9. 수익 모델\n* 기본 기능 무료 + 광고 배너/네이티브 광고\n* 프리미엄 구독 (월 3,900원)\n  * 광고 제거\n  * 실시간 객차 혼잡도, 패턴 기반 예측 알림, 워치 컴플리케이션 고급 기능\n\n## 10. 출시 범위 & 로드맵\n* v1.0 (M0) – 수도권 지하철 전 노선, Core + Personalization 기능\n* v1.1 (M2) – 광고 삽입, 위젯 & 워치, 오프라인 모드\n* v1.2 (M4) – 프리미엄 구독, 혼잡도 정보, 사용자 제보\n* v2.0 (M8) – 범위 확대: 인천·광역철도, GTX 예정 노선\n* v3.0 – 전국 주요 도시, KTX 간선\n\n## 11. 개발 전략\n* 하이브리드: 전 기능 1차 일괄 출시 후 2주 애자일 스프린트 개선\n* 기술 스택: React Native 또는 Flutter, Firebase 실시간 DB, AWS Lambda\n\n## 12. 요구 시스템 & 데이터\n* 실시간 열차 위치/지연 API 연결 (공공 API + 파트너십)\n* 장애/운행 중단 RSS 크롤러\n* 혼잡도: IoT 센서 연계 또는 Crowdsourcing\n* 노선·역 메타 정보 DB\n\n## 13. 주요 리스크 & 대응\n| 리스크 | 영향 | 대응 |\n|---------|------|------|\n| 실시간 데이터 정확도 부족 | 불신, 이탈 | 복수 데이터 소스 교차 검증, 사용자 제보 반영 |\n| 공공 API 제한/변경 | 서비스 중단 | 캐싱·폴백 전략, 파트너십 체결 |\n| 초기 개발 범위 과대 | 일정 지연 | 기능 우선순위 표, 스프린트 조정 |\n| 개인정보/GPS 민감 정보 | 규제·신뢰 하락 | 최소 수집, 로컬 처리, GDPR/개인정보법 준수 |\n\n## 14. 성공 가설\n1. 통근·통학자는 정확한 지연 알림을 위해 새로운 앱 설치 의향이 있다.\n2. 지연 알림 정확도가 95% 이상이면 하루 평균 3회 이상 앱을 사용한다.\n3. 프리미엄 혼잡도 기능은 MAU의 5% 이상이 구독한다.\n\n## 15. 승인\n* PM: ___________\n* Tech Lead: ___________\n* Design Lead: ___________\n* Date: ___________",
      "writedAt": "2025-08-30T05:58:08.631Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 수도권 통근/통학 사용자를 위한 실시간 전철 알림 및 대체 경로 제안 모바일 앱 개발. React Native 기반의 크로스 플랫폼 앱으로 Firebase를 백엔드로 활용하여 실시간 데이터 처리 및 사용자 인증/관리를 효율적으로 구현.\n- **핵심 기술 스택**: React Native, TypeScript, Firebase Firestore, Firebase Auth, Firebase Cloud Functions, Firebase ML, TailwindCSS 또는 Styled-components, Expo, GitHub Actions, AWS S3 (자산 백업).\n- **주요 기술 목표**: 높은 알림 정확도(≥ 95%), 낮은 앱 삭제율(< 5%), 실시간 데이터 처리, 확장 가능한 아키텍처 구축.\n- **주요 기술 가정**: 공공 API 및 파트너십을 통해 실시간 열차 데이터 확보 가능, Firebase 서비스 안정적 운영.\n\n## 2. 기술 스택\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 플랫폼             | React Native                | 크로스 플랫폼 개발, iOS/Android 동시 지원, 빠른 개발 속도 |\n| 언어               | TypeScript                  | 정적 타입 지원, 코드 안정성 및 유지보수성 향상 |\n| 데이터베이스        | Firebase Firestore            | 실시간 데이터 동기화, NoSQL, 확장성, 서버리스 |\n| 인증               | Firebase Auth               | 간편한 사용자 인증 및 관리, 다양한 인증 방식 지원 |\n| 백엔드 로직        | Firebase Cloud Functions      | 서버리스 함수, 이벤트 기반 로직 처리, 확장성 |\n| 머신러닝           | Firebase ML                 | 사용자 패턴 분석, 예측 알림 기능 구현 |\n| UI 프레임워크      | TailwindCSS or Styled-components | 컴포넌트 스타일링, 빠른 UI 개발, 유지보수성 |\n| 개발 도구          | Expo                      | 간편한 개발 환경 설정, 빌드 및 배포 |\n| CI/CD             | GitHub Actions              | 자동화된 빌드, 테스트, 배포 파이프라인 구축 |\n| 자산 백업         | AWS S3                    | 이미지, 비디오 등 정적 자산 백업 및 관리 |\n\n## 3. 시스템 아키텍처 설계\n\n### Top-Level building blocks\n- **모바일 앱 (React Native)**:\n    - UI 컴포넌트: 사용자 인터페이스 (알림 표시, 지도, 설정 등)\n    - 상태 관리: Redux 또는 Context API\n    - API 클라이언트: Firebase Cloud Functions 호출\n- **백엔드 (Firebase Cloud Functions)**:\n    - 데이터 수집기: 공공 API, RSS 크롤러 연동\n    - 데이터 처리기: 데이터 정제, 변환, 저장\n    - 알림 엔진: 실시간 알림 생성 및 전송\n    - 추천 엔진: 대체 경로 및 혼잡도 추천\n- **데이터베이스 (Firebase Firestore)**:\n    - 열차 정보: 실시간 열차 위치, 지연 정보\n    - 노선 정보: 역, 노선 메타 정보\n    - 사용자 정보: 즐겨찾기, 알림 설정\n    - 혼잡도 정보: 센서 데이터, 사용자 제보\n- **자산 저장소 (AWS S3)**:\n    - 이미지: 앱 내 사용 이미지, 워치 컴플리케이션 이미지\n    - 비디오: 튜토리얼, 광고 비디오\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[React Native 앱] --> B[Firebase Cloud Functions]\n    B --> C[Firebase Firestore]\n    B --> D[공공 API / RSS]\n    A --> E[AWS S3]\n```\n\n- React Native 앱은 Firebase Cloud Functions를 통해 데이터 요청 및 업데이트를 수행합니다.\n- Firebase Cloud Functions는 공공 API/RSS에서 데이터를 수집하고 Firebase Firestore에 저장합니다.\n- Firebase Cloud Functions는 데이터 변경 시 React Native 앱에 실시간 알림을 전송합니다.\n- React Native 앱은 AWS S3에 저장된 이미지/비디오 자산을 사용합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 열차 정보, 알림, 경로 추천 등 도메인별로 코드 분리\n- **Layer-Based Architecture**: UI 컴포넌트, 비즈니스 로직, 데이터 액세스 레이어로 분리\n- **Feature-Based Modules**: 각 기능(실시간 알림, 대체 경로 제안 등)별로 모듈화\n- **Shared Components**: 공통 UI 컴포넌트, 유틸리티 함수, 타입 정의를 공유 모듈로 관리\n\n**Universal File & Folder Structure**\n```\n/\n├── src/\n│   ├── components/          # UI 컴포넌트\n│   │   ├── common/           # 공통 컴포넌트\n│   │   ├── train/            # 열차 관련 컴포넌트\n│   │   ├── map/              # 지도 관련 컴포넌트\n│   │   └── ...\n│   ├── screens/             # 화면\n│   │   ├── home/             # 홈 화면\n│   │   ├── settings/         # 설정 화면\n│   │   └── ...\n│   ├── services/            # API 호출, 데이터 처리\n│   │   ├── api/              # API 클라이언트\n│   │   ├── train/            # 열차 정보 서비스\n│   │   ├── notification/     # 알림 서비스\n│   │   └── ...\n│   ├── models/              # 데이터 모델\n│   │   ├── train.ts          # 열차 정보 모델\n│   │   ├── user.ts           # 사용자 정보 모델\n│   │   └── ...\n│   ├── utils/               # 유틸리티 함수\n│   │   ├── date.ts           # 날짜 관련 유틸리티\n│   │   ├── location.ts       # 위치 관련 유틸리티\n│   │   └── ...\n│   ├── hooks/               # 커스텀 훅\n│   │   ├── useTrainData.ts   # 열차 데이터 훅\n│   │   └── ...\n│   ├── App.tsx              # 앱 진입점\n│   └── index.tsx            # React Native 앱 등록\n├── functions/              # Firebase Cloud Functions\n│   ├── src/\n│   │   ├── index.ts          # 함수 진입점\n│   │   ├── train/            # 열차 관련 함수\n│   │   ├── notification/     # 알림 관련 함수\n│   │   └── ...\n│   └── package.json\n├── .gitignore\n├── README.md\n├── package.json\n├── tsconfig.json\n└── ...\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: React Native 앱은 Firebase Cloud Functions HTTP 엔드포인트 호출하여 데이터 요청 및 업데이트. 응답은 JSON 형식으로 반환.\n- **Database Interaction**: Firebase Cloud Functions는 Firebase Firestore SDK를 사용하여 데이터 읽기/쓰기 수행.\n- **External Service Integration**: Firebase Cloud Functions는 `axios` 또는 `node-fetch`를 사용하여 공공 API 및 RSS 피드에서 데이터 수집.\n- **Real-time Communication**: Firebase Firestore의 실시간 리스너를 사용하여 데이터 변경 시 React Native 앱에 실시간 업데이트 전송.\n- **Data Synchronization**: Firebase Firestore의 트랜잭션 기능을 사용하여 데이터 일관성 유지.\n\n## 4. 성능 & 최적화 전략\n\n- **데이터 캐싱**: 자주 사용되는 데이터는 로컬 스토리지 또는 메모리에 캐싱하여 API 호출 횟수 최소화.\n- **이미지 최적화**: 이미지 크기 최적화, WebP 포맷 사용, CDN 활용.\n- **코드 분할**: React Native 번들 크기 줄이기 위해 코드 분할 적용.\n- **비동기 처리**: 시간이 오래 걸리는 작업은 비동기적으로 처리하여 UI 응답성 유지.\n\n## 5. 구현 로드맵 & 마일스톤\n### Phase 1: Foundation (MVP 구현)\n- **핵심 인프라**: React Native 프로젝트 설정, Firebase 프로젝트 설정, CI/CD 파이프라인 구축.\n- **필수 기능**: 실시간 열차 도착/지연 알림, 즐겨찾기 역/노선 관리.\n- **기본 보안**: Firebase Auth를 사용한 사용자 인증, 데이터베이스 보안 규칙 설정.\n- **개발 환경**: 개발 환경 설정, 코드 컨벤션 정의, 코드 리뷰 프로세스 구축.\n- **일정**: 8주\n\n### Phase 2: 기능 개선\n- **고급 기능**: 장애 발생/운행 중단 긴급 알림, 대체 노선/경로 제안, 실시간 혼잡도 정보.\n- **성능 최적화**: 데이터 캐싱, 이미지 최적화, 코드 분할.\n- **보안 강화**: 추가 보안 기능 구현 (예: 2단계 인증), 개인정보 보호 강화.\n- **모니터링 구현**: Firebase Performance Monitoring, Crashlytics 설정.\n- **일정**: 12주\n\n## 6. 리스크 평가 & 완화 전략\n### Technical Risk Analysis\n- **기술 리스크**: 실시간 데이터 정확도 부족, 공공 API 제한/변경, Firebase 서비스 장애.\n- **성능 리스크**: 실시간 데이터 처리량 증가, 알림 전송 지연, 앱 응답성 저하.\n- **보안 리스크**: 사용자 정보 유출, 데이터 위변조, 악성 코드 삽입.\n- **통합 리스크**: 공공 API 연동 실패, Firebase 서비스 연동 문제.\n- **완화 전략**:\n    - 복수 데이터 소스 교차 검증, 사용자 제보 반영.\n    - 캐싱/폴백 전략, 파트너십 체결.\n    - 데이터 암호화, 보안 코딩, 정기적인 보안 점검.\n    - API 연동 테스트, 에러 핸들링, 재시도 로직 구현.\n\n### Project Delivery Risks\n- **일정 리스크**: 개발 일정 지연, 기능 범위 변경.\n- **자원 리스크**: 개발 인력 부족, 기술 전문가 부재.\n- **품질 리스크**: 코드 품질 저하, 테스트 부족.\n- **배포 리스크**: 배포 환경 문제, 배포 실패.\n- **대응 계획**:\n    - 기능 우선순위 조정, 스프린트 조정.\n    - 추가 인력 확보, 기술 교육 제공.\n    - 코드 리뷰 강화, 자동화된 테스트 구축.\n    - 배포 전 테스트, 롤백 전략 수립.\n",
      "writedAt": "2025-08-30T05:58:08.631Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# Realtime Subway Notification App - Code Guidelines\n\n## 1. Project Overview\n\nThis project is a real-time subway notification application for the Seoul metropolitan area, built using React Native, TypeScript, Firebase, and related technologies. The application provides users with real-time train arrival and delay information, along with alternative route suggestions. Key architectural decisions include using Firebase Firestore for real-time data synchronization, Firebase Cloud Functions for backend logic, and React Native for cross-platform development.  The application architecture is a domain-driven, layer-based architecture with feature-based modules.\n\n## 2. Core Principles\n\n*   **Maintainability:** Code should be easy to understand, modify, and extend.\n*   **Readability:** Code should be clear, concise, and well-documented.\n*   **Testability:** Code should be designed to be easily tested (unit, integration, and end-to-end).\n*   **Performance:** Code should be optimized for speed and efficiency.\n*   **Scalability:** The architecture should support future growth and increased user load.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. TypeScript\n\n*   **File Organization:**\n    *   Use the folder structure defined in the TRD.\n    *   Group related components, services, and models within their respective directories.\n*   **Import/Dependency Management:**\n    *   Use absolute imports for internal modules (e.g., `import Train from 'src/models/train';`).\n    *   Use npm or yarn for dependency management.  Keep dependencies up-to-date.\n*   **Error Handling:**\n    *   Use `try...catch` blocks for handling potential errors.\n    *   Create custom error classes for specific error scenarios.\n    *   Log errors using a consistent logging mechanism (e.g., `console.error`).\n*   **Typing:**\n    *   **MUST** use explicit types for all variables, function parameters, and return values.  Use `any` only as a last resort and document why it is necessary.\n    *   **MUST** define interfaces or types for data models.\n    *   **MUST** leverage TypeScript's features like enums, generics, and union types where appropriate.\n\n### 3.2. React Native\n\n*   **File Organization:**\n    *   Follow the component-based structure. Each component should reside in its own directory with related files (e.g., `ComponentName/ComponentName.tsx`, `ComponentName/ComponentName.styles.ts`).\n*   **State Management:**\n    *   Use React Context API or Redux for global state management.  Choose the appropriate solution based on the complexity of the state.\n    *   Use `useState` for local component state.\n*   **Styling:**\n    *   Use TailwindCSS or Styled-components (consistent with the project's choice).\n    *   Keep styles separate from components in `.styles.ts` files.\n*   **Component Structure:**\n    *   Create small, reusable components.\n    *   Use functional components with hooks whenever possible.\n    *   Separate presentation (UI) from logic (data fetching, state updates) within components.\n\n### 3.3. Firebase\n\n*   **Firestore:**\n    *   Organize data in Firestore using a consistent schema.\n    *   Use appropriate indexing for efficient queries.\n    *   Implement security rules to protect data.\n    *   Use transactions to ensure data consistency.\n*   **Cloud Functions:**\n    *   Keep functions small and focused.\n    *   Use environment variables for configuration.\n    *   Implement proper error handling and logging.\n    *   Use TypeScript for all Cloud Functions.\n*   **Authentication:**\n    *   Use Firebase Auth for user authentication.\n    *   Handle authentication state changes using React Context or Redux.\n    *   Implement proper authorization based on user roles.\n\n### 3.4. Expo\n\n*   **Configuration:**\n    *   Use `app.json` or `app.config.js` for configuring the Expo app.\n    *   Manage environment variables using Expo's built-in support.\n*   **Plugins:**\n    *   Use Expo plugins for accessing native device features.\n    *   Keep plugins up-to-date.\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow:\n\n*   **Naming Conventions:**\n    *   Variables: `camelCase` (e.g., `trainArrivalTime`)\n    *   Functions: `camelCase` (e.g., `getTrainData`)\n    *   Components: `PascalCase` (e.g., `TrainDetails`)\n    *   Interfaces/Types: `PascalCase` (e.g., `Train`)\n    *   Constants: `UPPER_SNAKE_CASE` (e.g., `MAX_TRAIN_COUNT`)\n    *   Files: `kebab-case` (e.g., `train-details.tsx`)\n    *   Rationale: Consistent naming improves readability and maintainability.\n*   **Indentation:**\n    *   Use 2 spaces for indentation.\n    *   Rationale: Consistent indentation improves readability.\n*   **Line Length:**\n    *   Limit lines to 120 characters.\n    *   Rationale: Improves readability on various screen sizes.\n*   **Comments:**\n    *   Write clear and concise comments to explain complex logic or non-obvious code.\n    *   Use JSDoc style comments for documenting functions and components.\n    *   Rationale: Comments aid understanding and maintenance.\n*   **Error Handling:**\n    *   **MUST** implement comprehensive error handling using `try...catch` blocks.\n    *   **MUST** log errors with sufficient context for debugging.\n    *   **MUST** provide user-friendly error messages.\n    *   Rationale: Prevents application crashes and provides valuable debugging information.\n*   **Code Formatting:**\n    *   Use Prettier to automatically format code.\n    *   Rationale: Enforces a consistent code style across the project.\n*   **Immutability:**\n    *   Favor immutable data structures.  Use methods like `map`, `filter`, and `reduce` to avoid modifying existing arrays.\n    *   Rationale: Improves predictability and avoids unexpected side effects.\n*   **State Management:**\n    *   **MUST** choose either React Context or Redux.\n    *   **MUST** use reducers for complex state updates in Redux.\n    *   **MUST** separate state logic from UI components.\n    *   Rationale: Centralized state management simplifies debugging and allows for better component reusability.\n*   **API Calls:**\n    *   **MUST** encapsulate API calls in dedicated service files.\n    *   **MUST** handle API errors gracefully.\n    *   **MUST** use environment variables for API endpoints.\n    *   Rationale: Promotes code reusability and makes it easier to manage API endpoints.\n*   **Security:**\n    *   **MUST** sanitize user inputs to prevent XSS attacks.\n    *   **MUST** use HTTPS for all API requests.\n    *   **MUST** protect sensitive data using encryption.\n    *   Rationale: Protects the application and user data from security vulnerabilities.\n*   **Performance:**\n    *   **MUST** optimize images before uploading them to AWS S3.\n    *   **MUST** use memoization techniques (e.g., `React.memo`) to prevent unnecessary re-renders.\n    *   **MUST** avoid performing expensive operations in the main thread.\n    *   Rationale: Improves application performance and responsiveness.\n\n### 4.2. MUST NOT Do:\n\n*   **Global Variables:**\n    *   **MUST NOT** use global variables.\n    *   Rationale: Global variables can lead to naming conflicts and make it difficult to track state.\n*   **Magic Numbers/Strings:**\n    *   **MUST NOT** use magic numbers or strings directly in the code. Define constants instead.\n    *   Rationale: Improves readability and makes it easier to update values.\n*   **Nested Callbacks:**\n    *   **MUST NOT** use deeply nested callbacks (callback hell). Use Promises or async/await instead.\n    *   Rationale: Improves readability and makes it easier to handle asynchronous operations.\n*   **Console.log in Production:**\n    *   **MUST NOT** leave `console.log` statements in production code.\n    *   Rationale: `console.log` statements can impact performance and expose sensitive information.\n*   **Ignoring Errors:**\n    *   **MUST NOT** ignore errors. Handle them appropriately.\n    *   Rationale: Ignoring errors can lead to unexpected behavior and make it difficult to debug issues.\n*   **Direct DOM Manipulation:**\n    *   **MUST NOT** directly manipulate the DOM in React Native components. Use React's state management and rendering mechanisms instead.\n    *   Rationale: Direct DOM manipulation can lead to inconsistencies and performance issues.\n*   **Over-commenting:**\n    *   **MUST NOT** over-comment code. Comments should explain the *why*, not the *what*.\n    *   Rationale: Too many comments can clutter the code and make it difficult to read.\n*   **Committing Secrets to Git:**\n    *   **MUST NOT** commit API keys, passwords, or other sensitive information to Git. Use environment variables instead.\n    *   Rationale: Prevents security breaches.\n*   **Large Components:**\n    *   **MUST NOT** create huge, multi-responsibility components in a single file. Break down components into smaller, reusable pieces.\n    *   Rationale: Large components are difficult to understand, maintain, and test.\n*   **Complex State Management Pattern:**\n    *   **MUST NOT** overcomplicate state management. Start with simple solutions like `useState` or React Context and only move to more complex solutions like Redux if necessary.\n    *   Rationale: Overcomplicating state management can lead to unnecessary complexity and performance issues.\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n*   **Domain-Driven Design:** Organize code around business domains (e.g., `trains`, `users`, `notifications`).\n*   **Layered Architecture:** Separate UI components, business logic, and data access layers.\n*   **Feature-Based Modules:** Group components, services, and models related to a specific feature (e.g., `real-time-alerts`, `alternative-routes`).\n*   **Shared Components:** Create a `common` directory for reusable UI components and utility functions.\n\n### 5.2. Data Flow Patterns\n\n*   **Unidirectional Data Flow:** Data flows from parent components to child components via props. Child components update the state of parent components via callbacks.\n*   **Client-Server Communication:** React Native app communicates with Firebase Cloud Functions via HTTP requests.\n*   **Real-time Updates:** Firebase Firestore's real-time listeners are used to push data updates to the React Native app.\n\n### 5.3. State Management Conventions\n\n*   **React Context API (for simple state):**\n    *   Create a context provider to manage state.\n    *   Use `useContext` hook to access state from components.\n*   **Redux (for complex state):**\n    *   Define actions, reducers, and a store.\n    *   Use `connect` or `useSelector` and `useDispatch` to connect components to the store.\n\n### 5.4. API Design Standards\n\n*   **RESTful API:** Cloud Functions should expose RESTful APIs with standard HTTP methods (GET, POST, PUT, DELETE).\n*   **JSON Format:** Use JSON for request and response bodies.\n*   **Error Handling:** Return appropriate HTTP status codes for errors (e.g., 400 for bad request, 500 for server error).\n*   **Versioning:** Use API versioning to maintain backwards compatibility.\n\n## Example Code Snippets\n\n```typescript\n// MUST: Using explicit types\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nconst getUser = (id: string): User => {\n  // ... fetch user from database\n  return { id: id, name: \"John Doe\", email: \"john.doe@example.com\" };\n};\n// Explanation: Explicit types improve code clarity and prevent type-related errors.\n\n// MUST NOT: Using implicit any\nconst getUserBad = (id) => {\n  // ... fetch user from database\n  return { id: id, name: \"John Doe\", email: \"john.doe@example.com\" };\n};\n// Explanation: Implicit `any` types disable type checking and can lead to runtime errors.  Always use explicit types.\n```\n\n```typescript\n// MUST: Example of a React component using functional component and hooks\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\n\ninterface Props {\n  trainId: string;\n}\n\nconst TrainDetails: React.FC<Props> = ({ trainId }) => {\n  const [trainData, setTrainData] = useState(null);\n\n  useEffect(() => {\n    // Fetch train data using an API call or Firebase\n    const fetchTrainData = async () => {\n      // Simulate API call\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      setTrainData({ id: trainId, delay: 5 });\n    };\n\n    fetchTrainData();\n  }, [trainId]);\n\n  if (!trainData) {\n    return <Text>Loading...</Text>;\n  }\n\n  return (\n    <View style={styles.container}>\n      <Text>Train ID: {trainData.id}</Text>\n      <Text>Delay: {trainData.delay} minutes</Text>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 10,\n  },\n});\n\nexport default TrainDetails;\n\n// Explanation: This example demonstrates a well-structured React component using functional components, hooks for state management and side effects, and a separate styles object.\n\n// MUST NOT: Example of a large, complex component with mixed concerns\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, TextInput, Button, StyleSheet } from 'react-native';\n\nconst TrainDetailsBad = () => {\n  const [trainId, setTrainId] = useState('');\n  const [trainData, setTrainData] = useState(null);\n  const [error, setError] = useState(null);\n\n  const fetchTrainData = async () => {\n    try {\n      // Simulate API call\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      if (trainId === 'error') {\n        throw new Error('Failed to fetch train data');\n      }\n      setTrainData({ id: trainId, delay: 5 });\n    } catch (e: any) {\n      setError(e.message);\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text>Enter Train ID:</Text>\n      <TextInput\n        style={styles.input}\n        value={trainId}\n        onChangeText={setTrainId}\n      />\n      <Button title=\"Get Details\" onPress={fetchTrainData} />\n      {trainData && (\n        <View>\n          <Text>Train ID: {trainData.id}</Text>\n          <Text>Delay: {trainData.delay} minutes</Text>\n        </View>\n      )}\n      {error && <Text style={styles.error}>{error}</Text>}\n    </View>\n  );\n};\n\nconst stylesBad = StyleSheet.create({\n  container: {\n    padding: 10,\n  },\n  input: {\n    height: 40,\n    borderColor: 'gray',\n    borderWidth: 1,\n    marginBottom: 10,\n  },\n  error: {\n    color: 'red',\n  },\n});\n\n// Explanation: This component mixes UI, state management, data fetching, and error handling in a single file, making it difficult to understand, maintain, and test.  It should be broken down into smaller, more focused components.\n```\n\n```typescript\n// MUST: Using try...catch for error handling in Cloud Functions\nimport * as functions from 'firebase-functions';\nimport * as admin from 'firebase-admin';\n\nadmin.initializeApp();\n\nexport const getTrainStatus = functions.https.onRequest(async (req, res) => {\n  try {\n    const trainId = req.query.trainId;\n\n    if (!trainId) {\n      throw new Error('Train ID is required');\n    }\n\n    const snapshot = await admin.firestore().collection('trains').doc(trainId as string).get();\n\n    if (!snapshot.exists) {\n      throw new Error('Train not found');\n    }\n\n    const trainData = snapshot.data();\n\n    res.status(200).send(trainData);\n  } catch (error: any) {\n    console.error('Error getting train status:', error);\n    res.status(500).send(`Error getting train status: ${error.message}`);\n  }\n});\n\n// Explanation: This example demonstrates proper error handling in a Cloud Function using try...catch blocks and logging errors to the console.  It also returns appropriate HTTP status codes for different error scenarios.\n\n// MUST NOT: Ignoring errors in Cloud Functions\nimport * as functions from 'firebase-functions';\nimport * as admin from 'firebase-admin';\n\nadmin.initializeApp();\n\nexport const getTrainStatusBad = functions.https.onRequest(async (req, res) => {\n  const trainId = req.query.trainId;\n\n  const snapshot = await admin.firestore().collection('trains').doc(trainId as string).get();\n  const trainData = snapshot.data();\n\n  res.status(200).send(trainData);\n});\n\n// Explanation: This function does not handle any potential errors, such as a missing train ID, a non-existent train, or a database error.  This can lead to unexpected behavior and make it difficult to debug issues.\n```\n",
      "writedAt": "2025-08-30T05:58:08.631Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-30T05:58:08.631Z"
    },
    {
      "type": "clean-code",
      "content": "\n#   ",
      "writedAt": "2025-08-30T05:58:08.631Z"
    }
  ]
}